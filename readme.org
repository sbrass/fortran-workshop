#+startup: beamer
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+DATE: <2017-11-28 Di>
#+EMAIL: brass@physik.uni-siegen.de
#+LANGUAGE: de
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.3.1 (Org mode 9.1.3)

#+OPTIONS: H:2
#+LATEX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [smaller,compress,slidestop]
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+BEAMER_THEME: Pittsburgh
#+BEAMER_COLOR_THEME: solarized [accent=green]
#+BEAMER_FONT_THEME:
#+BEAMER_INNER_THEME:
#+BEAMER_OUTER_THEME:
#+BEAMER_HEADER: \usenavigationsymbolstemplate{}

#+LATEX: \setminted{fontsize=\footnotesize,bgcolor=white}
#+LATEX: \usemintedstyle{autumn}

* Fortran Workshop

** Übersicht

   - Einführung 20 Minuten
   - Vorbereitung (Installation Kompiler) 5 Minuten
   - Geschichte 15 Minuten
   - Syntax I (intrinsische Datentypen, I/O und Module) 10 Minuten
   - Übung 10 Minuten
   - Besprechung Übung 10 Minuten
   - Syntax II (=allocatable= und /array language/) 20 Minuten
   - Übung 20 Minuten
   - Besprechung Übung 20 Minuten
   - 15 Minuten Pause
   - Syntax III (=derived types= und =pointer=) 30 Minuten
   - Übung 30 Minuten
   - Besprechung Übung 30 Minuten

* Begrüßung und Vorbereitung

** Tutoren
   :PROPERTIES:
   :EXPORT_OPTIONS: width=0.6textwidth
   :END:

   - Simon Braß, Doktorand in der AG Theoretische Teilchenphysik
   - Jessica Reuter, Lehramt für Mathematik und Informatik

*** Fragen? Probleme?                                        :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
      #+CAPTION: Quelle: [[https://xkcd.com]]
      #+ATTR_LATEX: :width 0.6\textwidth
      [[./images/complex_conjugate.png]]
** Ablauf                                                    :B_exampleblock:
   :PROPERTIES:
   :BEAMER_env: exampleblock
   :END:

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 1. Tag: Grundlagen

     - Vorbereitung
     - Geschichte
     - Konzepte und Syntax
     - Strukturen
     - Datentypen
     - Ein-/Ausgabe

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 2. Tag: OOP

     - =derived types=
     - Zeiger und Prozeduren-Zeiger
     - =allocatables=
     - Polymorphie und Vererbung
     - Typ-gebundene Prozeduren

*** Uhrzeit und Ort

    - EN-D308, 4.12.2012, 16:00 - 20:00 Uhr
    - EN-D308, 5.12.2012, 16:00 - 20:00 Uhr

** Vorbereitung

*** Editor

    - Emacs
    - Vim / vi / kak
    - Sublime
    - Atom

*** Kompiler

    - nagfor
    - ifort
    - *gfortran*

*** Anleitungen und Material

    Anleitungen und Material unter: [[http://www.tp.nt.uni-siegen.de/+brass/]]

* Geschichte und Einführung

** Geschichte von Fortran

*** Formula Translator (Fortran)                             :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - 1950er :: Entwicklung bei IBM um das Team von John Backus als Assembler-Alternative
    - 1966 :: 1. Standardisierung durch ANSI als =FORTAN 66=
    - 1978 :: 2. Standardiserung als =FORTRAN 77= / Durchbruch als Sprache
    - 1991 :: Einführung von abstrakten Datentypen und /data hiding/, sowie Standardisierung der /array language/
    - 1997 :: Fortran 95 als /high perfomance/ Sprache
    - 2004 :: Fortran 2003 mit Objekt-orientierten Konzepten
    - 2008 :: Fortran 2008 mit /submodules/ und /coarrays/
    - 2012-heute :: Fortran 2015 ...

** Philosophie von Fortran

   - einfach-lesbare Syntax
   - Entwicklung für Lochkarten-Computer *fixed form* für =FORTAN 66/77=
   - Seit =Fortran 90= *free form* als Standard
   - vergleichbare Effizienz zu Assembler-Code
     #+CAPTION: Lochkarte ([[http://newsadultg3.over-blog.com/2017/05/how-to-write-a-factorial-program-in-fortran.html][Quelle]])
     #+ATTR_LATEX: :width 0.7\textwidth
     [[./images/punchcard.jpg]]
** Beispiele

*** /fixed form/                                             :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC fortran
      c     independent variables for real graph: number of final state
      c     legs times 3, take away 4 for 4-momentum conservation, add 2
      c     for x_1 and x_2, and take away an overall azimuth
            real * 8 btilde,xx(ndiminteg),www0
            real * 8 xrad(3)
            real * 8 xborn(ndiminteg-3)
    #+END_SRC

*** /free form/                                              :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        call self%rand_gen%rand(randkoord)
        randkoord = self%sys_len * randkoord
        m = int(randkoord(1)) + 1
        n = int(randkoord(2)) + 1
        call cyclic_coord (self, m, n, up, down, left, right)

        deltaE = 2.0_dp * ( self%couple_const * self&
             &%grid(m, n)*(self%grid(m, left) + self%grid(m, right) +&
             & self%grid(up, n) + self%grid(down, n)) + self%mag_field &
             &* self%grid(m, n))
    #+END_SRC

** Fortran 2003 Standard

*** Neuerungen in =Fortran 2003=

    - =parametrized derived types=, Konstruktoren, Destruktoren und eingeschränkte Zugriffe
    - Polymorphie, Typ-Erweiterung, Vererbung, dynamische Typ-Allokierung und Typ-gebundene Prozeduren
    - allokierbare Komponenten, =deferred type parameters=
    - Prozeduren-Zeiger
    - =C bindings=

*** Gfortran

    - (fast) vollständige Unterstützung durch Gfortran =7.2.0= [[https://gcc.gnu.org/wiki/Fortran2003Status][siehe]]
    - größte Kompiler-Unterstützung an sich (ifort/NAGfor/Gfortran)

** Parallelisierung

*** Threading                                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Parallelisierung mit OpenMP durch Direktiven mit Threads standardisiert

*** Message-Passing Interface                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Parallelisierung im Message-Passing Interface standardisiert

* Konzepte und Syntax

** Warum =Fortran=?

*** Vorteile von =Fortran=

    - gewöhnliche Sprache
    - Syntax nahe an Matrix- und Vektorproblemen
    - strenge Speicherverwaltung
    - Polymorphie mit Typ-Sicherheit
    - =by-reference= Argumentübergabe

*** Nachteile von =Fortran=

    - schlechte Kompiler-Unterstützung
    - keine Templates (=C++=)
    - langsame Zeiger

** Hauptprogramm und Module

*** Scope

    Definition eines Scopes durch Strukturen
    - Hauptprogramm
    - Module
    - Prozeduren
    - =derived types=

*** /data hiding/

    - Verschachtelung von Scopes
    - Zugriff auf Daten eines niedrigeren Scopes
    - kein Zugriff auf Daten eines höhren Scopes
    - explizites Öffnen / Verschließen von Daten

** Beispiel Syntax und Konzepte

*** Hauptprogramm                                            :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Hauptprogramm                                           :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       program beispiel
         ! use beispiel_module
         implicit none
         ! Variablen-Deklaration
         ! Programm
       contains
         ! Prozeduren
         ! Zugriff auf alle Variablen
         ! des Hauptprogrammes
       end program beispiel
     #+END_SRC

*** Modul                                                    :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Modul                                                   :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       module beispiel_module
         use beispiel2_module
         ! Variablen-Deklarationen
         ! Typ-Definitioen
         !
       contains
         ! Module-Prozeduren
         ! Zugriff auf alle Variablen
         ! des Moduls
       end module beispiel_module
     #+END_SRC

*** Beipsiel                                                 :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Kein Zugriff von =beispiel_module= auf =program=
    - Zugriff von =contained procedure= in =program= auf =program=

** Datentypen

*** Intrinsiche Datentypen                                   :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        integer :: i                  ! Ganze Zahlen
        real :: x                     ! Reelle Zahlen
        complex :: z                  ! Komplexe Zahlen (5., 2.): 5+2i
        character(len=100) :: str     ! Zeichenkette mit Länge 100
        logical :: flag               ! Boolean (.True. oder .False.)
        type(haus) :: eigenheim       ! Derived Type
    #+END_SRC

*** =implicit none=                                            :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

    *Wichtig:* Aus Rückwartskompatibilität immer =implicit none= benutzen, damit Fortran nicht automatisch Variablen mit entsprechenden Typen deklariert.

*** Kommentare                                                 :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    Kommentare im Quellcode können mit =!= erstellt werden. Jeder Ausdruck nach =!= wird vom Kompiler ignoriert.
** Ein- und Ausgabe

*** Listen-formatierte Ein-/Ausgabe                          :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
      print *, "Hallo Welt!" ! Schreibt "Hallo Welt!" in die Standardausgabe
      write (*, *) "Hallo Welt!"
      write (*, *) "Geben Sie einen ganze Zahl ein:"
      read (*, *) i ! Liest einen Wert von der Standardausgabe ein
      write (u, *) "Ich werde in die unit = ", u, " geschrieben."
    #+END_SRC

*** =iso_fortran_env=                                        :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - andere /unit/ als =*= (Standardein-/ausgabe) möglich
    - Standardausgabe-, Standardfehlerausgabe-/unit/ in =iso_fortran_env=

    #+BEGIN_SRC f90
        use iso_fortran_env, only: error_unit
        ! Schreibt Fehlermeldung auf stderr
        write (error_unit, *) "Fehlermeldung"

    #+END_SRC

** Kompilieren

   - statisch-kompilierte Sprache
   - Kompilieren zu Machinen-Code
     #+BEGIN_SRC sh
       gfortran \
           -Wall \ # alle Warnungen
           -g \    # Debug-Symbole
           -c example1.f08 -o example1.o
     #+END_SRC
   - Linken zu einem ausführbaren Programm
     #+BEGIN_SRC sh
       gfortran -o example1 example1.o
     #+END_SRC

*** Programm: Beispiel 1                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

    #+NAME: example1
    #+BEGIN_SRC f90 :export none
      program example1
        implicit none
        integer :: i
        print *, "*** Beispiel 1 ***"
        print *, "Hallo Welt!"
        i = 42
        print *, "i = ", i
      end program example1
    #+END_SRC

*** Ausgabe                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

    #+BEGIN_SRC sh
      gfortran -o example.o \
                -c example.f08
      gfortran -o example example.o
      ./example
      ,*** Beispiel 1 ***
      Hallo Welt!
      i =           42
    #+END_SRC

** Operatoren und mathematische Funktionen

   #+NAME: example3
   #+BEGIN_SRC f90 :export none
     print *, "a + b = ", a + b      ! Addition
     print *, "a - b = ", a - b      ! Subtraktion
     print *, "a * b = ", a * b      ! Multiplikation
     print *, "a / b = ", a / b      ! Division
     print *, "a ** b = ", a ** b    ! Potenz
   #+END_SRC
   - alle mathematischen Operatoren und Funktionen für komplexe Zahlen
   - Vielzahl von mathematischen Standardfunktionen: =mod=, =sin=, =log=,...
   - logische Operatoren: =.and.=, =.or.=, =.not.=,...
   - vergleichende Operatoren: ===, =/==, =>=, =<=, =>==, =<==
   #+NAME: example3
   #+BEGIN_SRC f90 :export none
       print *, ".true. .and. .false.", .true. .and. .false.
       print *, ".true. .or. .true.", .true. .or. .true.
       print *, "(a - b) /= (a + b)", (a - b) /= (a + b)
   #+END_SRC

** Aufgabe

   - Deklarieren Sie mit allen Datentypen Variablen.
   - Definieren Sie für alle Variablen Werte.
   - Geben Sie alle Variablen auf der Standardausgabe aus.
   - Wenden Sie (ausgewählte) mathematische Operatoren auf Variablen gleichen und verschieden Typs an.

*** Grundgerüst                                              :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:
    #+BEGIN_SRC f90
      program aufgabe1
        implicit none
        integer :: zahl
        ! ...
        zahl = 42
        ! ...
        print *, "zahl = ", zahl
        ! ...
        print *, "zahl + 1. = ", zahl + 1.
      end program aufgabe1
    #+END_SRC

** Arrays

   - von allen Datentypen (auch =derived types=)
   - maximal 7-dimensionaler Array
   - Konstruktor durch =[...]=
   - allokierbarer Array mit =allocatable=

   #+NAME: example2
   #+BEGIN_SRC f90 :exports code
     integer, dimension(10) :: iarray
     integer, dimension(10, 2) :: iarray2
     integer, dimension(:), allocatable :: iarray3
     ! Maximal 7-dim. Array
     iarray = 10                     ! alle Element auf 10 setzen
     iarray = [(i,i=1, 10)]           ! Konstruktor
     iarray = [1, 1, 2, 3, 5, 8, 13, 21, 43, 64]
     iarray2(:, 1) = [(i, i = 1, 10)]
     iarray2(:, 2) = [(i**2, i = 1, 10)]
     iarray3 = [1, 2]                ! Allocate on assignment
     deallocate (iarray3)
     allocate (iarray3(10), source = 1)
   #+END_SRC

** =if-clause= und Schleifen
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:
   - =if-clause= prüft logischen Ausdruck
   - logischen Ausdruck aus logischen Operatoren und Variablen
   - =select case=
   - =do= / =do while= / =cycle= / =exit=
   #+NAME: example4
   #+BEGIN_SRC f90 :export none
     if (a == b) then ! /= für ungleich
        print *, "a == b"
     else if (a >= b)  then ! >, <, <=
        print *, "a >= b"
     else
        print *, "a steht in keiner Relation zu b"
     end if
   #+END_SRC

   #+NAME: example5
   #+BEGIN_SRC f90 :export none
     do i = 1, 10 ! Drittes Argument gibt Iterationsvorschrift
        print *, "i = ", i
     end do
     do i = 10, 1, -1
        print *, "i = ", i
     end do
   #+END_SRC

   #+NAME: example6
   #+BEGIN_SRC f90 :export none
     do while (a > b)
        b = b + 2
        print *, "b = b + 2 = ", b
     end do
   #+END_SRC

   #+BEGIN_SRC f90 :export
       do ! "Endlos-Schleife"
          ! Tue etwas
          if (bedingung1) then
             cycle ! Wiederhole Schleife sofort
          else if (bedingung2) then
             exit ! Beende Schleife sofort
          else
             ! Tue etwas ganz anderes
          end if
       end do
   #+END_SRC

   #+BEGIN_SRC f90
    ! select case als Ersatz für verschachtelte if-clauses
    select case (test)
    case(10)
       print *, 10
    case(:9)
       print *, "<10"
    case default
       print *, "Was auch immer..."
    end select

   #+END_SRC

** Aufgabe
   - Deklarieren Sie eindimensionale Arrays von verschiedenen Datentypen.
   - Testen Sie welche mathematischen Operatoren erlaubt sind:
     - Skalar und Array
     - Array und Array
   - Deklarieren, (de)allokieren Sie Arrays.
   - Nutzen Sie eine Schleife um einen Array elementeweise auszugeben.

*** Hinweis
    - Testen Sie, ob ein =allocatable= Objekt allokiert ist, mit =allocated(...)=.
    - Probieren Sie ein =allocate-on-assignment= aus.
    - Greifen Sie auf ein Element mit Index =i= mit =iarray(i)= zu.

** Funktionen

   Eine Funktion liefert einen Rückgabe-Wert aus verschiedenen Argumenten.
   Ähnlich einer Abbildung aus der Mathematik.
   #+BEGIN_SRC f90 :export none
     ! Funktion vom Typ integer
     integer function add (a, b) result (c)
       integer, intent(in) :: a
       integer, intent(in) :: b
       c = a + b
     end function add
     ! ...
     print *, "2 + 3 = ", add(2, 3)
   #+END_SRC
   - =pure= Funktionen sind ohne Nebeneffekte wie Ein-/Ausgabe
   - =elemental= Funktionen werden elementweise auf Arrays angewant, setzt =pure= voraus.
   - Bei Definition ohne =result= wird automatisch eine Rückgabe-Variable mit dem Namen und des Types der Funktion angelegt.

** Subroutinen
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   Subroutinen können mehrere Argumente zurückgeben.
   #+NAME: example7
   #+BEGIN_SRC f90 :export none
     subroutine volume_and_length (a, b, volume, circ)
       real, dimension(3), intent(in) :: a
       real, dimension(3), intent(in) :: b
       real, intent(out) :: volume
       real, intent(out) :: circ
       real, dimension(3) :: c
       call vector_product (a, b, c)
       volume = sqrt(dot_product(c, c))
       circ = 2*(sqrt(dot_product(a, a)) + sqrt(dot_product(b, b)))
     contains
       subroutine vector_product (a, b, c)
         real, dimension(3), intent(in) :: a, b
         real, dimension(3), intent(out) :: c
         c = [(a(1) * b(2) - a(2) * b(1)), &
              (a(1) * b(3) - a(3) * b(1)), &
              (a(2) * b(3) - a(3) * b(2))]
       end subroutine vector_product
     end subroutine volume_and_length
   #+END_SRC
   - Funktionen und Subroutinen können andere Prozeduren über =contains= enthalten.
   - =intent=-Angabe geben Veränderlichkeit von Argumenten an: =in=, =out=, =inout=
   - =optional=-Argumente können, müssen aber nicht übergeben werden.
   #+BEGIN_SRC f90
     character(:), allocatable, optional :: text
     if (present (text)) print *, text
   #+END_SRC
   - Übergabe der Argumente in *Reihenfolge*
   - Übergabe der Argumente über Name des Arguments: =a=array, b=array2=
   - =intent(in/inout)=-Arrays können /assumed-shape/ haben
   #+BEGIN_SRC f90
     subroutine map_index (index1, index2)
       integer, dimension(:), intent(in) :: index1
       integer, dimension(size(index)), intent(out) :: index2
     end subroutine map_index
     ! im Programm
     integer, dimension(5) :: i1, i2
     call map_index (i1, i2)
   #+END_SRC

*** Problem                                                    :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    Wie bringt man Struktur und logische Ordnung in die Prozeduren und das Hauptprogram?

** Modul
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   - Strukturierung und logische Ordnung
   - Modularisierung
   - Zugriffsrechte
   - Schnittstellen und Definitionen
   - Wiederverwendbarkeit
   #+BEGIN_SRC f90
     module vektoren
       implicit none
       private ! Immer alles auf private setzen
       public :: vector3_product ! explizit exportieren
     contains
       subroutine vector3_product (a, b, c)
         real, dimension(3), intent(in) :: a, b
         real, dimension(3), intent(out) :: c
         c = [(a(1) * b(2) - a(2) * b(1)), &
              (a(1) * b(3) - a(3) * b(1)), &
              (a(2) * b(3) - a(3) * b(2))]
       end subroutine vector3_product
     end module vektoren
   #+END_SRC
   - Modulkopf
   - =use=, =use ::, only: name => module_name=
   - =contains=
   - =private=, =public=

** Zeichenketten
   - =allocatable characters=
   - =assumed length=

** Aufgabe

   Finden Sie alle Cluster

** =derived types=
   Einfacher =derived type=
   #+BEGIN_SRC f90
     ! Typ Definition
     type :: haus_t
        real :: length
        real :: width
        real :: height
     end type haus_t
     type(haus_t) :: eigenheim
     ! Konstruktor
     eigenheim = haus_t (10.0, 8.0, 12.0) ! Länge, Breite und Höhe
     eigenheim = haus_t ( &               ! Beliebige Reihenfolge
          width = 8.0, &                  ! mit explizitem Aufruf
          height = 12.0, &                ! der Argumente
          length = 10.0)
     ! Oder eigener Konstruktor durch ein überladenes Interface von haus_t
   #+END_SRC
   Erweiterer =derived type= mit Vererbung
   #+BEGIN_SRC f90
       type, extends(haus_t) :: halle_t
          character(len=20) :: fassadenfarbe = "grün"
          logical :: brandschutz = .false.
       end type halle_t
       type(halle_t) :: gewerbe ! hat alle Eigenschaften von haus_t und hallo_t
   #+END_SRC

*** Weitere Attribute

    - public ::
    - private ::
    - allocatable :: Speicher kann dynamisch mit =allocate= bereit gestellt werden
    - pointer :: Zeigevariable (kann Variable mit Attribut =target= zeigen)
    - target :: Zielvariable
    - dimension :: Variable ist ein Array (max. 7 dimensional)
    - intent :: im Kontext einer Prozeduren: =in=, =out= oder =inout=, legt fest wie Variable in der Prozedure benutzt werden kann
    - optional ::
    - save ::

    #+BEGIN_SRC f90
    integer, public :: test ! Ist in allen Programmteilen sichtbar
    integer, private :: private_test ! Ist in anderen Modulen nicht sichtbar/außerhalb eines Types
    integer, dimension(10) :: array ! 1-dim. Array mit zehn Elementen
    integer, dimension(:), allocatable :: alloc_array ! allokierbare, 1-dim. Array
    integer, pointer :: zeiger
    integer, target :: ziel = 42
    !
    allocate (alloc_array(25)) ! allokiere 25 Elemente
    zeiger => ziel
    zeiger => test ! Gibt eine Fehlermeldung
    #+END_SR
* Polymorphe Objekte und Type-gebundene Prozeduren

  #+BEGIN_SRC f90
      class(haus_t), allocatable :: objekt ! Polymorphes Objekt auf Basis von haus_t
      allocate (halle_t :: objekt) ! allokiere vererbten Typ halle_t von haus_t
      select type (object) ! Typ-sicherer Aufruf
      type is (halle_t)
         object%brandschutz = .true.
      class is (haus_t)
         object%length = 100.0
      end select
  #+END_SRC

* Beispiele                                                      :B_appendix:
  :PROPERTIES:
  :BEAMER_env: appendix
  :END:

** Programm: Example 1

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example1.f08
   <<example1>>
   #+END_SRC

** Programm: Example 2

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example2.f08
      program example2
        implicit none
        integer :: i
        <<example2>>
        print *, "*** Example 2 ***"
        print *, "iarray = ", iarray
        print *, "iarray2 = ", iarray2
        print *, "iarray3 = ", iarray3
      end program example2
   #+END_SRC

** Programm: Example 3

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example3.f08
     program example3
       complex :: a
       complex :: b
       print *, "*** Example 3 ***"
       a = (2, 1)
       b = (-1, 2)
       print *, "a = ", a
       print *, "b = ", b
       <<example3>>
     end program example3
   #+END_SRC

** Programm: Example 4-6

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example46.f08
     program example46
       implicit none
       integer :: a = 5, b = -1
       integer :: i
       print *, "*** Beispiel 4-6 ***"
       print *, "a = ", a
       print *, "b = ", b
       <<example4>>
       <<example5>>
       <<example6>>
     end program example46
   #+END_SRC

** Programm: Example 7

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example7.f08
     program example7
       implicit none
       real, dimension(3) :: a, b
       real :: vol, circ
       print *, "*** Beispiel 7 ***"
       a = [1., 2., 3.]; b = [-1., 2., 1.]
       call volume_and_length (a, b, vol, circ)
       print *, "a = ", a, "b = ", b
       print *, "vol = ", vol, "circ = ", circ
     end program example7
     <<example7>>
   #+END_SRC
