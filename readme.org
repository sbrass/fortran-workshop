#+startup: beamer
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+DATE: <2017-11-28 Di>
#+EMAIL: brass@physik.uni-siegen.de
#+LANGUAGE: de
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.3.1 (Org mode 9.1.3)

#+OPTIONS: H:2
#+LATEX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [smaller,compress,slidestop]
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+BEAMER_THEME: Pittsburgh
#+BEAMER_COLOR_THEME: solarized [accent=green]
#+BEAMER_FONT_THEME:
#+BEAMER_INNER_THEME:
#+BEAMER_OUTER_THEME:
#+BEAMER_HEADER: \usenavigationsymbolstemplate{}

#+LATEX: \setminted{fontsize=\footnotesize,bgcolor=white}
#+LATEX: \usemintedstyle{autumn}

* Fortran Workshop

** Übersicht

   - Einführung 20 Minuten
   - Vorbereitung (Installation Kompiler) 5 Minuten
   - Geschichte 15 Minuten
   - Syntax I (intrinsische Datentypen, I/O und Module) 10 Minuten
   - Übung 10 Minuten
   - Besprechung Übung 10 Minuten
   - Syntax II (=allocatable= und /array language/) 20 Minuten
   - Übung 20 Minuten
   - Besprechung Übung 20 Minuten
   - 15 Minuten Pause
   - Syntax III (=derived types= und =pointer=) 30 Minuten
   - Übung 30 Minuten
   - Besprechung Übung 30 Minuten

* Begrüßung und Vorbereitung

** Tutoren

   - Simon Braß, Doktorand in der AG Theoretische Teilchenphysik
   - Jessica Reuter, Lehramt für Mathematik und Informatik

** Ablauf                                                    :B_exampleblock:
   :PROPERTIES:
   :BEAMER_env: exampleblock
   :END:

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 1. Tag: Grundlagen

     - Vorbereitung
     - Geschichte
     - Konzepte und Syntax
     - Strukturen
     - Datentypen
     - Ein-/Ausgabe

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 2. Tag: OOP

     - Zeiger und Prozeduren-Zeiger
     - =allocatables=
     - Polymorphie und Vererbung
     - Typ-gebundene Prozeduren

*** Uhrzeit und Ort

    - EN-D308, 4.12.2012, 16:00 - 20:00 Uhr
    - EN-D308, 5.12.2012, 16:00 - 20:00 Uhr

** Vorbereitung

*** Editor

    - Emacs
    - Vim / vi / kak
    - Sublime
    - Atom

*** Kompiler

    - nagfor
    - ifort
    - *gfortran*

*** Anleitungen und Material

    Anleitungen und Material unter: [[http://www.tp.nt.uni-siegen.de/+brass/]]

* Geschichte und Einführung

** Geschichte von Fortran

*** Formula Translator (Fortran)                             :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - 1950er :: Entwicklung bei IBM um das Team von John Backus als Assembler-Alternative
    - 1966 :: 1. Standardisierung durch ANSI als =FORTAN 66=
    - 1978 :: 2. Standardiserung als =FORTRAN 77= / Durchbruch als Sprache
    - 1991 :: Einführung von abstrakten Datentypen und /data hiding/, sowie Standardisierung der /array language/
    - 1997 :: Fortran 95 als /high perfomance/ Sprache
    - 2004 :: Fortran 2003 mit Objekt-orientierten Konzepten
    - 2008 :: Fortran 2008 mit /submodules/ und /coarrays/
    - 2012-heute :: Fortran 2015 ...

** Philosophie von Fortran

   - einfach-lesbare Syntax
   - Entwicklung für Lochkarten-Computer *fixed form* für =FORTAN 66/77=
   - Seit =Fortran 90= *free form* als Standard
   - vergleichbare Effizienz zu Assembler-Code

** Beispiele

*** /fixed form/                                             :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC fortran
      c     independent variables for real graph: number of final state
      c     legs times 3, take away 4 for 4-momentum conservation, add 2
      c     for x_1 and x_2, and take away an overall azimuth
            real * 8 btilde,xx(ndiminteg),www0
            real * 8 xrad(3)
            real * 8 xborn(ndiminteg-3)
    #+END_SRC

*** /free form/                                              :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        call self%rand_gen%rand(randkoord)
        randkoord = self%sys_len * randkoord
        m = int(randkoord(1)) + 1
        n = int(randkoord(2)) + 1
        call cyclic_coord (self, m, n, up, down, left, right)

        deltaE = 2.0_dp * ( self%couple_const * self&
             &%grid(m, n)*(self%grid(m, left) + self%grid(m, right) +&
             & self%grid(up, n) + self%grid(down, n)) + self%mag_field &
             &* self%grid(m, n))
    #+END_SRC

** Fortran 2003 Standard

*** Neuerungen in =Fortran 2003=

    - =derived types= :: =parametrized derived types=, Konstruktoren und Destruktoren (Finalizer) und Beschränkung der Zugriffbarkeit
    - OOP :: Typ-Erweiterung und Vererbung, Polymorphie, dynamische Typ-Allokierung und Typ-gebundene Prozeduren
    - Datenmanipulierung :: allokiebare Komponenten, =deferred type parameters=, ...
    - =procedure pointer= ::
    - =C bindings= ::

*** Gfortran

    - (fast) vollständige Unterstützung durch Gfortran =7.2.0= [[https://gcc.gnu.org/wiki/Fortran2003Status][siehe]]
    - größte Kompiler-Unterstützung an sich (ifort/NAGfor/Gfortran): =Fortran 2003=

** Parallelisierung

*** Threading                                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Parallelisierung mit OpenMP durch Direktiven mit Threads standardisiert

*** Message-Passing Interface                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Parallelisierung im Message-Passing Interface standardisiert

* Konzepte und Syntax

** Warum =Fortran=?

*** Vorteile von =Fortran=

    - gewöhnliche Sprache
    - Syntax nahe an Matrix- und Vektorproblemen
    - strenge Speicherverwaltung
    - Polymorphie mit Typ-Sicherheit
    - standardmäßig =by-reference=

*** Nachteile von =Fortran=

    - schlechte Kompiler-Unterstützung
    - keine Templates (=C++=)
    - langsame Zeiger

** Hauptprogramm und Module

*** Scope

    Definition eines Scopes durch Strukturen
    - Hauptprogramm
    - Module
    - Prozeduren
    - =derived types=

*** /data hiding/

    - Verschachtelung von Scopes
    - Zugriff auf Daten eines niedrigeren Scopes
    - kein Zugriff auf Daten eines höhren Scopes
    - explizites Öffnen / Verschließen von Daten

** Beispiel Syntax und Konzepte

*** Hauptprogramm                                            :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Hauptprogramm                                           :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       program beispiel
         ! use beispiel_module
         implicit none
         ! Variablen-Deklaration
         ! Programm
       contains
         ! Prozeduren
         ! Zugriff auf alle Variablen
         ! des Hauptprogrammes
       end program beispiel
     #+END_SRC

*** Modul                                                    :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Modul                                                   :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       module beispiel_module
         use beispiel2_module
         ! Variablen-Deklarationen
         ! Typ-Definitioen
         !
       contains
         ! Module-Prozeduren
         ! Zugriff auf alle Variablen
         ! des Moduls
       end module beispiel_module
     #+END_SRC

*** Beipsiel                                                 :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Kein Zugriff von =beispiel_module= auf =program=
    - Zugriff von =contained procedure= in =program= auf =program=

** Datentypen

*** Intrinsiche Datentypen                                   :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        integer :: i                  ! Ganze Zahlen
        real :: x                     ! Reelle Zahlen
        complex :: z                  ! Komplexe Zahlen
        character(len=100) :: str     ! Zeichenkette mit Länge 100
        logical :: flag               ! Boolean (.True. oder .False.)
        type(haus) :: eigenheim       ! Derived Type
    #+END_SRC

*** =implicit none=                                            :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

    *Wichtig:* Aus Rückwartskompatibilität immer =implicit none= benutzen, damit Fortran nicht automatisch Variablen mit entsprechenden Typen deklariert.

** Ein- und Ausgabe

*** Listen-formatierte Ein-/Ausgabe                          :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
      print *, "Hallo Welt!"
      write (*, *) "Hallo Welt!"
      write (*, *) "Geben Sie einen ganze Zahl ein:"
      read (*, *) i
      write (u, *) "Ich werde in die unit = ", u, " geschrieben."
    #+END_SRC

*** =iso_fortran_env=                                        :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - andere /unit/ als =*= möglich
    - Standardausgabe-, Standardfehlerausgabe-/unit/ in =iso_fortran_env=

    #+BEGIN_SRC f90
        use iso_fortran_env, only: error_unit
        ! Schreibe Fehlermeldung auf stderr
        write (error_unit, *) "Fehlermeldung"

    #+END_SRC

** Kompilieren

   - statisch-kompilierte Sprache
   - Kompilieren zu Machinen-Code
     #+BEGIN_SRC sh
       gfortran \
           -Wall \ # alle Warnungen
           -g \    # Debug-Symbole
           -c example1.f08 -o example1.o
     #+END_SRC
   - Linken zu einem ausführbaren Programm
     #+BEGIN_SRC sh
       gfortran -o example1 example1.o
     #+END_SRC

*** Programm: Beispiel 1                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

    #+NAME: example1
    #+BEGIN_SRC f90 :export code :tangle examples/example1.f08
      program example1
        implicit none
        integer :: i
        print *, "*** Beispiel 1 ***"
        print *, "Hallo Welt!"
        i = 42
        print *, "i = ", i
      end program example1
    #+END_SRC

*** Ausgabe                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

    #+BEGIN_SRC sh
      gfortran -o example.o \
                -c example.f08
      gfortran -o example example.o
      ./example
      ,*** Beispiel 1 ***
      Hallo Welt!
      i =           42
    #+END_SRC

** Operatoren und mathematische Funktionen

   #+NAME: example3
   #+BEGIN_SRC f90 :export code
     print *, "a + b = ", a + b      ! Addition
     print *, "a - b = ", a - b      ! Subtraktion
     print *, "a * b = ", a * b      ! Multiplikation
     print *, "a / b = ", a / b      ! Division
     print *, "a ** b = ", a ** b    ! Potenz
   #+END_SRC
   - alle mathematischen Operatoren und Funktionen für komplexe Zahlen
   - Vielzahl von mathematischen Standardfunktionen: =mod=, =sin=, =log=,...
   - logische Operatoren: =.and.=, =.or.=, =.not.=,...

** Arrays

   - von allen Datentypen (auch =derived types=)
   - maximal 7-dimensionaler Array
   - Konstruktor durch =[...]=
   - allokierbarer Array mit =allocatable=

   #+NAME: example2
   #+BEGIN_SRC f90 :exports code
     integer, dimension(10) :: iarray
     integer, dimension(10, 2) :: iarray2
     integer, dimension(:), allocatable :: iarray3
     ! Maximal 7-dim. Array
     iarray = 10                     ! alle Element auf 10 setzen
     iarray = [(i,i=1, 10)]           ! Konstruktor
     iarray = [1, 1, 2, 3, 5, 8, 13, 21, 43, 64]
     iarray2(:, 1) = [(i, i = 1, 10)]
     iarray2(:, 2) = [(i**2, i = 1, 10)]
     iarray3 = [1, 2]                ! Allocate on assignment
     deallocate (iarray3)
     allocate (iarray3(10), source = 1)
   #+END_SRC

** =if-clause= und Schleifen
   - =if-clause= prüft logischen Ausdruck
   - logischen Ausdruck aus logischen Operatoren und Variablen
   - select case
   - do / do while / cycle / exit
   #+NAME: example4
   #+BEGIN_SRC f90 :export none
       if (a == b) then ! /= für ungleich
          print *, "a == b"
       else if (a >= b)  then ! > für echt größer
          print *, "a >= b"
       else
          print *, "a steht in keiner Relation zu b"
       end if
   #+END_SRC

** Funktionen

   - pure
   - elemental

** Subroutinen

   - contains

** Argumente

   - intent
   - optional
   - =assumed length/size=

** Zeichenketten
   - =allocatable characters=
   - =assumed length=
** =derived types=
   Einfacher =derived type=
   #+BEGIN_SRC f90
     ! Typ Definition
     type :: haus_t
        real :: length
        real :: width
        real :: height
     end type haus_t
     type(haus_t) :: eigenheim
     ! Konstruktor
     eigenheim = haus_t (10.0, 8.0, 12.0) ! Länge, Breite und Höhe
     eigenheim = haus_t ( &               ! Beliebige Reihenfolge
          width = 8.0, &                  ! mit explizitem Aufruf
          height = 12.0, &                ! der Argumente
          length = 10.0)
     ! Oder eigener Konstruktor durch ein überladenes Interface von haus_t
   #+END_SRC
   Erweiterer =derived type= mit Vererbung
   #+BEGIN_SRC f90
       type, extends(haus_t) :: halle_t
          character(len=20) :: fassadenfarbe = "grün"
          logical :: brandschutz = .false.
       end type halle_t
       type(halle_t) :: gewerbe ! hat alle Eigenschaften von haus_t und hallo_t
   #+END_SRC

*** Weitere Attribute

    - public ::
    - private ::
    - allocatable :: Speicher kann dynamisch mit =allocate= bereit gestellt werden
    - pointer :: Zeigevariable (kann Variable mit Attribut =target= zeigen)
    - target :: Zielvariable
    - dimension :: Variable ist ein Array (max. 7 dimensional)
    - intent :: im Kontext einer Prozeduren: =in=, =out= oder =inout=, legt fest wie Variable in der Prozedure benutzt werden kann
    - optional ::
    - save ::

    #+BEGIN_SRC f90
        integer, public :: test ! Ist in allen Programmteilen sichtbar
        integer, private :: private_test ! Ist in anderen Modulen nicht sichtbar/außerhalb eines Types
        integer, dimension(10) :: array ! 1-dim. Array mit zehn Elementen
        integer, dimension(:), allocatable :: alloc_array ! allokierbare, 1-dim. Array
        integer, pointer :: zeiger
        integer, target :: ziel = 42
        !
        allocate (alloc_array(25)) ! allokiere 25 Elemente
        zeiger => ziel
        zeiger => test ! Gibt eine Fehlermeldung
    #+END_SRC

* Polymorphe Objekte und Type-gebundene Prozeduren

  #+BEGIN_SRC f90
      class(haus_t), allocatable :: objekt ! Polymorphes Objekt auf Basis von haus_t
      allocate (halle_t :: objekt) ! allokiere vererbten Typ halle_t von haus_t
      select type (object) ! Typ-sicherer Aufruf
      type is (halle_t)
         object%brandschutz = .true.
      class is (haus_t)
         object%length = 100.0
      end select
  #+END_SRC

* Beispiele                                                      :B_appendix:
  :PROPERTIES:
  :BEAMER_env: appendix
  :END:

** Programm: Example 1

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example1.f08
   <<example1>>
   #+END_SRC

** Programm: Example 2

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example2.f08
      program example2
        implicit none
        integer :: i
        <<example2>>
        print *, "*** Example 2 ***"
        print *, "iarray = ", iarray
        print *, "iarray2 = ", iarray2
        print *, "iarray3 = ", iarray3
      end program example2
   #+END_SRC

** Programm: Example 3

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example3.f08
     program example3
       complex :: a
       complex :: b
       print *, "*** Example 3 ***"
       a = (2, 1)
       b = (-1, 2)
       print *, "a = ", a
       print *, "b = ", b
       <<example3>>
     end program example3
   #+END_SRC
