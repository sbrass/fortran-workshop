#+startup: beamer
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+TITLE: Fortran-Workshop
#+SUBTITLE: Workshopreihe Programmiersprachen
#+AUTHOR: \href{mailto:brass@phsyik.uni-siegen.de}{Simon Braß}, Jessica Reuter
#+DATE: \today{}
#+EMAIL: brass@physik.uni-siegen.de
#+LANGUAGE: de-de
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.3.1 (Org mode 9.1.3)

#+OPTIONS: H:2
#+LATEX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [smaller,compress,slidestop]
#+LATEX_HEADER: \usepackage[AUTO]{babel}
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+BEAMER_THEME: Pittsburgh
#+BEAMER_COLOR_THEME: solarized [accent=green]
#+BEAMER_FONT_THEME:
#+BEAMER_INNER_THEME:
#+BEAMER_OUTER_THEME:
#+BEAMER_HEADER: \institute[Uni Siegen]{Theoretische Physik I\\\url{http://www.tp.nt.uni-siegen.de/+brass/}}
#+BEAMER_HEADER: \titlegraphic{\includegraphics[height=1cm]{images/unilogo.pdf}}
#+BEAMER_HEADER: \usenavigationsymbolstemplate{}

#+LATEX: \setminted{fontsize=\footnotesize,bgcolor=white}
#+LATEX: \usemintedstyle{autumn}

* Begrüßung und Vorbereitung

** Tutoren
   :PROPERTIES:
   :EXPORT_OPTIONS: width=0.6textwidth
   :END:

   - Simon Braß, Doktorand in der AG Theoretische Teilchenphysik
   - Jessica Reuter, Lehramt für Mathematik und Informatik

*** Fragen? Probleme?                                        :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    #+CAPTION: Quelle: [[https://xkcd.com]]
    #+ATTR_LATEX: :width 0.6\textwidth
    [[./images/complex_conjugate.png]]
** Ablauf                                                    :B_exampleblock:
   :PROPERTIES:
   :BEAMER_env: exampleblock
   :END:

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 1. Tag: Grundlagen

     - Vorbereitung
     - Geschichte
     - Konzepte und Syntax
     - Strukturen
     - Datentypen
     - Ein-/Ausgabe

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 2. Tag: OOP

     - =derived types=
     - Zeiger und Prozeduren-Zeiger
     - =allocatables=
     - Polymorphie und Vererbung
     - Typ-gebundene Prozeduren

*** Uhrzeit und Ort

    - EN-D308, 4.12.2012, 16:00 - 20:00 Uhr
    - EN-D308, 5.12.2012, 16:00 - 20:00 Uhr

** Vorbereitung

*** Editor

    - Emacs
    - Vim / vi / kak
    - Sublime
    - Atom

*** Kompiler

    - nagfor
    - ifort
    - *gfortran*

*** Anleitungen und Material

    Anleitungen und Material unter: [[http://www.tp.nt.uni-siegen.de/+brass/]]

* Geschichte und Einführung

** Geschichte von Fortran

*** Formula Translator (Fortran)                             :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - 1950er :: Entwicklung bei IBM um das Team von John Backus als Assembler-Alternative
    - 1966 :: 1. Standardisierung durch ANSI als =FORTAN 66=
    - 1978 :: 2. Standardiserung als =FORTRAN 77= / Durchbruch als Sprache
    - 1991 :: Einführung von abstrakten Datentypen und /data hiding/, sowie Standardisierung der /array language/
    - 1997 :: Fortran 95 als /high perfomance/ Sprache
    - 2004 :: Fortran 2003 mit Objekt-orientierten Konzepten
    - 2010 :: Fortran 2008 mit /submodules/ und /coarrays/
    - 2012-heute :: Fortran 2018 ...

** Philosophie von Fortran

   - einfach-lesbare und verständliche Syntax
   - vergleichbare Effizienz zu Assembler-Code
   - Mathematik-nahe Umsetzung FORmula TRANnslator
   - *fixed form* Syntax für Lochkarten-Computer in =FORTAN 66/77=
   - *free form* seit =Fortran 90= als Standard
   #+CAPTION: Lochkarte ([[http://newsadultg3.over-blog.com/2017/05/how-to-write-a-factorial-program-in-fortran.html][Quelle]])
   #+ATTR_LATEX: :width 0.7\textwidth
   [[./images/punchcard.jpg]]
** Beispiele

*** /fixed form/                                             :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC fortran
      c     independent variables for real graph: number of final state
      c     legs times 3, take away 4 for 4-momentum conservation, add 2
      c     for x_1 and x_2, and take away an overall azimuth
            real * 8 btilde,xx(ndiminteg),www0
            real * 8 xrad(3)
            real * 8 xborn(ndiminteg-3)
    #+END_SRC

*** /free form/                                              :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        call self%rand_gen%rand(randkoord)
        randkoord = self%sys_len * randkoord
        m = int(randkoord(1)) + 1
        n = int(randkoord(2)) + 1
        call cyclic_coord (self, m, n, up, down, left, right)

        deltaE = 2.0_dp * ( self%couple_const * self&
             &%grid(m, n)*(self%grid(m, left) + self%grid(m, right) +&
             & self%grid(up, n) + self%grid(down, n)) + self%mag_field &
             &* self%grid(m, n))
    #+END_SRC

** Fortran 2003 Standard

*** Neuerungen in =Fortran 2003=

    - =parametrized derived types=, Konstruktoren, Destruktoren und eingeschränkte Zugriffe
    - Polymorphie, Typ-Erweiterung, Vererbung, dynamische Typ-Allokierung und Typ-gebundene Prozeduren
    - allokierbare Komponenten, =deferred type parameters=
    - Prozeduren-Zeiger
    - =C bindings=

*** Gfortran

    - (fast) vollständige Unterstützung durch Gfortran =7.2.0= [[https://gcc.gnu.org/wiki/Fortran2003Status][(GCC Wiki)]]
    - größte Kompiler-Unterstützung an sich (ifort/NAGfor/Gfortran)

** Parallelisierung

*** Threading                                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Parallelisierung mit OpenMP durch Direktiven mit Threads standardisiert

*** Message-Passing Interface                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Parallelisierung im Message-Passing Interface standardisiert

* Konzepte und Syntax

** Warum =Fortran=?

*** Vorteile von =Fortran=

    - gewöhnliche Sprache
    - Syntax nahe an Matrix- und Vektorproblemen
    - strenge Speicherverwaltung
    - Polymorphie mit Typ-Sicherheit
    - =by-reference= Argumentübergabe

*** Nachteile von =Fortran=

    - schlechte Kompiler-Unterstützung
    - keine Templates (=C++=)
    - langsame Zeiger

** Aufteilung und Verschachtelung
*** Scope

    Definition eines Scopes durch Strukturen
    - Hauptprogramm
    - Module
    - Prozeduren
    - =derived types=

*** /data hiding/

    - Verschachtelung von Scopes
    - Zugriff auf Daten eines niedrigeren Scopes
    - kein Zugriff auf Daten eines höhren Scopes
    - explizites Öffnen / Verschließen von Daten

** Beispiel Syntax und Konzepte

*** Hauptprogramm                                            :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Hauptprogramm                                           :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       program beispiel
         ! use beispiel_module
         implicit none
         ! Variablen-Deklaration
         ! Programm
       contains
         ! Prozeduren
         ! Zugriff auf alle Variablen
         ! des Hauptprogrammes
       end program beispiel
     #+END_SRC

*** Modul                                                    :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Modul                                                   :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       module beispiel_module
         use beispiel2_module
         ! Variablen-Deklarationen
         ! Typ-Definitioen
         !
       contains
         ! Module-Prozeduren
         ! Zugriff auf alle Variablen
         ! des Moduls
       end module beispiel_module
     #+END_SRC

*** Beipsiel                                                 :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Kein Zugriff von =beispiel_module= auf =program=
    - Zugriff von =contained procedure= in =program= auf =program=

** Besondere Zeichen

*** Kommentare                                                 :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    Kommentare im Quellcode können mit =!= erstellt werden. Jeder Ausdruck nach =!= wird vom Kompiler ignoriert.

*** Zeilenumbruch                                              :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    Überlange Zeilen (=>=127= Zeichen) werden mit =&= gebrochen.

*** Statement-Ende                                             :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    Mit einem =;= kann ein Statement-Ende gesetzt werden so, dass mehrere Statements in eine Zeile geschrieben werden können.

    #+BEGIN_SRC f90
        ! Ich bin ein Kommenatar.
        real :: x = 1.5 ! Ich bin auch ein Kommentar.
        character(len=100) :: str = "Hallo Welt! Ich bin eine viel zu lange &
             & Zeichenkette, denn ich passe nicht in eine Zeile."
        i = 42; b = 10; c = (0.5, 4.5)
    #+END_SRC

** Datentypen

*** Intrinsiche Datentypen                                   :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        integer :: i                  ! Ganze Zahlen
        real :: x                     ! Reelle Zahlen
        complex :: z                  ! Komplexe Zahlen (5., 2.): 5+2i
        character(len=100) :: str     ! Zeichenkette mit Länge 100
        logical :: flag               ! Boolean (.True. oder .False.)
        type(haus) :: eigenheim       ! Derived Type
    #+END_SRC

*** =implicit none=                                            :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

    *Wichtig:* Aus Rückwartskompatibilität immer =implicit none= benutzen, damit Fortran nicht automatisch Variablen mit entsprechenden Typen deklariert.

** Ein- und Ausgabe

*** Listen-formatierte Ein-/Ausgabe                          :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    #+BEGIN_SRC f90
        print *, "Hallo Welt!" ! Schreibt "Hallo Welt!" in die Standardausgabe
        write (*, *) "Hallo Welt!"
        write (*, *) "Geben Sie einen ganze Zahl ein:"
        read (*, *) i ! Liest einen Wert von der Standardeingabe ein
        write (u, *) "Ich werde in die unit = ", u, " geschrieben."
    #+END_SRC

*** =iso_fortran_env=                                        :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - andere /unit/ als =*= (Standardein-/ausgabe) möglich
    - Standardausgabe-, Standardfehlerausgabe-/unit/ in =iso_fortran_env=

    #+BEGIN_SRC f90
        use iso_fortran_env, only: error_unit
        ! Schreibt Fehlermeldung auf stderr
        write (error_unit, *) "Fehlermeldung"

    #+END_SRC

** Kompilieren

   - statisch-kompilierte Sprache
   - Kompilieren zu Machinen-Code
     #+BEGIN_SRC sh
       gfortran \
           -Wall \ # alle Warnungen
       -g \    # Debug-Symbole
       -c example1.f08 -o example1.o
     #+END_SRC
   - Linken zu einem ausführbaren Programm
     #+BEGIN_SRC sh
       gfortran -o example1 example1.o
     #+END_SRC

*** Programm: Beispiel 1                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

    #+NAME: example1
    #+BEGIN_SRC f90 :export none
      program example1
        implicit none
        integer :: i
        print *, "*** Beispiel 1 ***"
        print *, "Hallo Welt!"
        i = 42
        print *, "i = ", i
      end program example1
    #+END_SRC

*** Ausgabe                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

    #+BEGIN_SRC sh
      gfortran -o example.o \
               -c example.f08
      gfortran -o example example.o
      ./example
      ,*** Beispiel 1 ***
      Hallo Welt!
      i =           42
    #+END_SRC


** Aufgabe

   - Schreiben Sie das Programm: Beispiel 1 ab und kompilieren Sie es.
   - Was ist der Unterschied zwischen =example.o= und =example.f08=?
   - Was geschieht beim sog. Linken mit =example.o=?

*** =objdump=                                                :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    Benutzen Sie =objdump -d example1.o=, um sich den Machinen-Code anzusehen.
    Versuchen Sie das Beispiel /ohne/ die =print=-Anweisungen.

** Variablen-Eigenschaften

   Alle Variablen können weitere Eigenschaften besitzen:
   - bei =parameter= kann sich die Variable nicht mehr ändern,
   - durch =dimension= wird eine Variable zu einem Variablen-Array,
   - durch =allocatable= kann der Speicher /dynamisch/ angefordert werden,
   - durch =pointer= kann mit einer Variable auf eine andere Variable mit =target= gezeigt werden.

*** Achtung                                                    :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

    Eigenschaften können sich gegenseitig ausschließen!
    #+BEGIN_SRC f90
        integer, pointer, target :: i1 ! Verboten
        integer, allocatable, pointer :: i2 ! Verboten
        integer, parameter, pointer :: i3 ! Verboten
        ! ...
    #+END_SRC

** Operatoren und mathematische Funktionen

   #+NAME: example3
   #+BEGIN_SRC f90 :export none
       print *, "a + b = ", a + b      ! Addition
       print *, "a - b = ", a - b      ! Subtraktion
       print *, "a * b = ", a * b      ! Multiplikation
       print *, "a / b = ", a / b      ! Division
       print *, "a ** b = ", a ** b    ! Potenz
   #+END_SRC
   - alle mathematischen Operatoren und Funktionen für komplexe Zahlen
   - Vielzahl von mathematischen Standardfunktionen: =mod=, =sin=, =log=,...
   - logische Operatoren: =.and.=, =.or.=, =.not.=,...
   - vergleichende Operatoren: ===, =/==, =>=, =<=, =>==, =<==
   #+NAME: example3
   #+BEGIN_SRC f90 :export none
       print *, ".true. .and. .false.", .true. .and. .false.
       print *, ".true. .or. .true.", .true. .or. .true.
       print *, "(a - b) /= (a + b)", (a - b) /= (a + b)
   #+END_SRC

** Aufgabe

   - Deklarieren Sie mit allen Datentypen Variablen.
   - Definieren Sie für alle Variablen Werte.
   - Geben Sie alle Variablen auf der Standardausgabe aus.
   - Wenden Sie (ausgewählte) mathematische Operatoren auf Variablen gleichen und verschieden Typs an.

*** Grundgerüst                                              :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:
    #+BEGIN_SRC f90
      program aufgabe1
        implicit none
        integer :: zahl
        ! ...
        zahl = 42
        ! ...
        print *, "zahl = ", zahl
        ! ...
        print *, "zahl + 1. = ", zahl + 1.
      end program aufgabe1
    #+END_SRC

** Arrays
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   - von allen Datentypen (auch =derived types=)
   - maximal 7-dimensionaler Array
   - 1-dm. Konstruktor durch =[...]=
   - allokierbarer Array mit =allocatable=

   #+NAME: example2
   #+BEGIN_SRC f90
       integer, dimension(10) :: iarray
       integer, dimension(10, 2) :: iarray2
       integer, dimension(:), allocatable :: iarray3
       ! Maximal 7-dim. Array
       iarray = 10                     ! alle Element auf 10 setzen
       iarray = [(i,i=1, 10)]           ! Konstruktor
       iarray = [1, 1, 2, 3, 5, 8, 13, 21, 43, 64]
       iarray2(:, 1) = [(i, i = 1, 10)]
       iarray2(:, 2) = [(i**2, i = 1, 10)]
       iarray3 = [1, 2]                ! Allocate on assignment
       deallocate (iarray3)
       allocate (iarray3(10), source = 1)
   #+END_SRC
*** Index                                                    :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Zugriff auf Elemente eines Array durch Index
    - Einzel-Element oder Unter-Array
    - Zugriff auf /slice/ durch =:=
    - Index-Variablen vom Typ =integer=
    #+BEGIN_SRC f90
        integer, dimension(10, 3) :: 2d_array
        ! ...
        print *, 2d_array(5, 2) ! Element
        print *, 2d_array(1:5, 1) ! Unterarray
        print *, 2d_array(5, :) ! Slice im höchsten Index
        print *, 2d_array(2 * i, i) ! i = {1, 2, 3}
    #+END_SRC

*** Array-Speicher                                             :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:

    - Spalten-orientierter Array
    - Anordnung von Array-Speicher nach niedrigster zur höchster Dimension
    - Effizienz bei Schleifen über mehr-dim. Arrays

*** Schlechtes Beispiel                                      :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:
    #+BEGIN_SRC f90
        integer, dimension(100, 25) :: a
        integer :: i, j
        do i = 1, 100 ! linker, innerer Index
           do j = 1, 25 ! rechter, äußerer Index
              print *, a(i)
           end do
        end do
    #+END_SRC

    Die Schleife über den Index =j= läuft über Spalten und der Index =i= über die Reihen.
    Daher muss im obigen Beispiel sehr viel im Speicher hin und her gesprungen werden.

*** Gutes Beispiel                                           :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:
    #+BEGIN_SRC f90
        integer, dimension(100, 25) :: a
        integer :: i, j
        do j = 1, 25 ! rechter, äußerer Index
           do i = 1, 100 ! linker, innerer Index
              print *, a(i)
           end do
        end do
    #+END_SRC
    Der Speicher wird in der vorgegebenen Reihenfolge abgelaufen so, dass der Array effizient ausgelesen wird.
    Im Beispiel macht das natürlich keinen Unterschied wegen des =print= auf die Standardausgabe!


** =if-clause= und Schleifen
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:
   - =if-clause= prüft logischen Ausdruck
   - logischen Ausdruck aus logischen Operatoren und Variablen
   - =select case=
   - =do= / =do while= / =cycle= / =exit=
   #+NAME: example4
   #+BEGIN_SRC f90 :export none
       if (a == b) then ! /= für ungleich
          print *, "a == b"
       else if (a >= b)  then ! >, <, <=
          print *, "a >= b"
       else
          print *, "a steht in keiner Relation zu b"
       end if
   #+END_SRC

   #+NAME: example5
   #+BEGIN_SRC f90 :export none
       do i = 1, 10 ! Drittes Argument gibt Iterationsvorschrift
          print *, "i = ", i
       end do
       do i = 10, 1, -1
          print *, "i = ", i
       end do
   #+END_SRC

   #+NAME: example6
   #+BEGIN_SRC f90 :export none
       do while (a > b)
          b = b + 2
          print *, "b = b + 2 = ", b
       end do
   #+END_SRC

   #+BEGIN_SRC f90
       do ! "Endlos-Schleife"
          ! Tue etwas
          if (bedingung1) then
             cycle ! Wiederhole Schleife sofort
          else if (bedingung2) then
             exit ! Beende Schleife sofort
          else
             ! Tue etwas ganz anderes
          end if
       end do
   #+END_SRC

   #+BEGIN_SRC f90
       ! select case als Ersatz für verschachtelte if-clauses
       select case (test)
       case(10)
          print *, 10
       case(:9)
          print *, "<10"
       case default
          print *, "Was auch immer..."
       end select
   #+END_SRC

   #+BEGIN_SRC f90
       ! elementweise Zuordnung
       forall (i = 1:10)
          array(i) = array(i) + 1
       end forall
       ! elementweise Bearbeitung über Bedingung
       where (array == 1)
          array = array + 1
       else where
          array = 0
       end where
   #+END_SRC

** Aufgabe
   - Deklarieren Sie eindimensionale Arrays von verschiedenen Datentypen.
   - Testen Sie welche mathematischen Operatoren erlaubt sind:
     - Skalar und Array
     - Array und Array
   - Deklarieren, (de)allokieren Sie Arrays.
   - Nutzen Sie eine Schleife um einen Array elementeweise auszugeben.

*** Hinweis
    - Testen Sie, ob ein =allocatable= Objekt allokiert ist, mit =allocated(...)=.
    - Probieren Sie ein =allocate-on-assignment= aus.
    - Greifen Sie auf ein Element mit Index =i= mit =iarray(i)= zu.

** Funktionen

   Eine Funktion liefert einen Rückgabe-Wert aus verschiedenen Argumenten.
   Ähnlich einer Abbildung aus der Mathematik.
   #+BEGIN_SRC f90 
     ! Funktion vom Typ integer
     integer function add (a, b) result (c)
       integer, intent(in) :: a
       integer, intent(in) :: b
       c = a + b
     end function add
     ! ...
     print *, "2 + 3 = ", add(2, 3)
   #+END_SRC
   - =pure= Funktionen sind ohne Nebeneffekte wie Ein-/Ausgabe
   - =elemental= Funktionen werden elementweise auf Arrays angewant, setzt =pure= voraus.
   - Bei Definition ohne =result= wird automatisch eine Rückgabe-Variable mit dem Namen und des Types der Funktion angelegt.


** Aufgabe

   - Schreiben Sie eine ganzzahlige Funktion, welche einen 1-dim. Array vom Typ =integer= nimmt und die Summe der Elemente berechnet.
   - Schreiben Sie eine reelle Funktion, welche einen 1-dim. Array vom Typ =real= nimmt und das Produkt aller Elemente bildet.
   - Schreiben Sie eine logische Funktion, welche nur =.true.= liefert, wenn kein Element eines =integer= Array null ist.
   - Schreiben Sie eine reelle Funktion, welche einen 2-dim. Array vom Typ =real= nimmt und die Elemente der ersten Dimension durch Elemente der zweiten Dimension teilt.
   - Schreiben Sie eine reelle Funktion, welche das Skalarprodukt zwischen zwei gleich-großen Vektoren bestimmt.

*** Hinweis                                                  :B_exampleblock:
    :PROPERTIES:
    :BEAMER_env: exampleblock
    :END:

    - Mit der Funktion =size= können Sie die Größe eines Arrays bestimmen.
    - [[Aufgabe: Funktionen][Lösung]]

** Subroutinen
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   Subroutinen können mehrere Argumente zurückgeben.
   #+NAME: example7
   #+BEGIN_SRC f90 :export none
     subroutine volume_and_length (a, b, volume, circ)
       real, dimension(3), intent(in) :: a
       real, dimension(3), intent(in) :: b
       real, intent(out) :: volume
       real, intent(out) :: circ
       real, dimension(3) :: c
       call vector_product (a, b, c)
       volume = sqrt(dot_product(c, c))
       circ = 2*(sqrt(dot_product(a, a)) + sqrt(dot_product(b, b)))
     contains
       subroutine vector_product (a, b, c)
         real, dimension(3), intent(in) :: a, b
         real, dimension(3), intent(out) :: c
         c = [(a(1) * b(2) - a(2) * b(1)), &
              (a(1) * b(3) - a(3) * b(1)), &
              (a(2) * b(3) - a(3) * b(2))]
       end subroutine vector_product
     end subroutine volume_and_length
   #+END_SRC
   - Funktionen und Subroutinen können andere Prozeduren über =contains= enthalten.
   - =intent=-Angabe geben Veränderlichkeit von Argumenten an: =in=, =out=, =inout=
   - =optional=-Argumente können, müssen aber nicht übergeben werden.
   #+BEGIN_SRC f90
       character(:), allocatable, optional :: text
       if (present (text)) print *, text
   #+END_SRC
   - Übergabe der Argumente in *Reihenfolge*
   - Übergabe der Argumente über Name des Arguments: =a=array, b=array2=
   - =intent(in/inout)=-Arrays können /assumed-shape/ haben
   #+BEGIN_SRC f90
     subroutine map_index (index1, index2)
       integer, dimension(:), intent(in) :: index1
       integer, dimension(size(index)), intent(out) :: index2
     end subroutine map_index
     ! im Programm
     integer, dimension(5) :: i1, i2
     call map_index (i1, i2)
   #+END_SRC

*** Problem                                                    :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    Wie bringt man Struktur und logische Ordnung in die Prozeduren und das Hauptprogram?

** Modul
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   - Strukturierung und logische Ordnung
   - Modularisierung
   - Zugriffsrechte
   - Schnittstellen und Definitionen
   - Wiederverwendbarkeit
   #+BEGIN_SRC f90
     module vektoren
       implicit none
       private ! Immer alles auf private setzen
       public :: vector3_product ! explizit exportieren
     contains
       subroutine vector3_product (a, b, c)
         real, dimension(3), intent(in) :: a, b
         real, dimension(3), intent(out) :: c
         c = [(a(1) * b(2) - a(2) * b(1)), &
              (a(1) * b(3) - a(3) * b(1)), &
              (a(2) * b(3) - a(3) * b(2))]
       end subroutine vector3_product
     end module vektoren
   #+END_SRC
   - Einbindung von Modulen durch =use=
   - Beschränkung durch =only=
   - Umbenennung von geladenen Prozeduren =neu => alt=
   - =private= Elemente nicht nach außen sichtbar
   - =public= Elemente nach außen sichtbar
   #+BEGIN_SRC f90
     program main
       use vektoren, only: vector_product => vector3_product
       ! Nur vector3_product importieren und umbenennen
       ! ...
       call vector_product (a, b, c)
       print *, "a x b = ", c
     end program main
   #+END_SRC

** Zeichenketten

   - Zeichenketten sind /quasi/ 1-dim. Arrays vom Typ =character=
   - *Spezielle Syntax* =character(:)=
   - Zugriff auf Teile einer Zeichenkette durch Indizes
   - Zeichenketten zusammenfügen mit =//=
     #+NAME: example8
     #+BEGIN_SRC f90
       character(len=100) :: str
       character(:), allocatable :: str2, str3 ! allocatable-string
       str = "Hallo Welt!"
       print *, str
       str2 = "Hallo Welt! Ich bin neuer!!"
       print *, str2
       str3  = "Und meine Geschichte ist es..."
       str2 = str2 // " " // str3           ! String konkatieren mit //
       print *, str2
     #+END_SRC

** Aufgabe

   Finden Sie alle Cluster

** =derived types=
   Einfacher =derived type=
   #+BEGIN_SRC f90
       ! Typ Definition
       type :: haus_t
          real :: length
          real :: width
          real :: height
       end type haus_t
       type(haus_t) :: eigenheim
       ! Konstruktor
       eigenheim = haus_t (10.0, 8.0, 12.0) ! Länge, Breite und Höhe
       eigenheim = haus_t ( &               ! Beliebige Reihenfolge
            width = 8.0, &                  ! mit explizitem Aufruf
            height = 12.0, &                ! der Argumente
            length = 10.0)
       ! Oder eigener Konstruktor durch ein überladenes Interface von haus_t
   #+END_SRC
   Erweiterer =derived type= mit Vererbung
   #+BEGIN_SRC f90
       type, extends(haus_t) :: halle_t
          character(len=20) :: fassadenfarbe = "grün"
          logical :: brandschutz = .false.
       end type halle_t
       type(halle_t) :: gewerbe ! hat alle Eigenschaften von haus_t und hallo_t
   #+END_SRC

*** Weitere Attribute

    - public ::
    - private ::
    - allocatable :: Speicher kann dynamisch mit =allocate= bereit gestellt werden
    - pointer :: Zeigevariable (kann Variable mit Attribut =target= zeigen)
    - target :: Zielvariable
    - dimension :: Variable ist ein Array (max. 7 dimensional)
    - intent :: im Kontext einer Prozeduren: =in=, =out= oder =inout=, legt fest wie Variable in der Prozedure benutzt werden kann
    - optional ::
    - save ::

    #+BEGIN_SRC f90
    integer, public :: test ! Ist in allen Programmteilen sichtbar
    integer, private :: private_test ! Ist in anderen Modulen nicht sichtbar/außerhalb eines Types
    integer, dimension(10) :: array ! 1-dim. Array mit zehn Elementen
    integer, dimension(:), allocatable :: alloc_array ! allokierbare, 1-dim. Array
    integer, pointer :: zeiger
    integer, target :: ziel = 42
    !
    allocate (alloc_array(25)) ! allokiere 25 Elemente
    zeiger => ziel
    zeiger => test ! Gibt eine Fehlermeldung
    #+END_SRC
   
** Polymorphe Objekte und Type-gebundene Prozeduren

   #+BEGIN_SRC f90
       class(haus_t), allocatable :: objekt ! Polymorphes Objekt auf Basis von haus_t
       allocate (halle_t :: objekt) ! allokiere vererbten Typ halle_t von haus_t
       select type (object) ! Typ-sicherer Aufruf
       type is (halle_t)
          object%brandschutz = .true.
       class is (haus_t)
          object%length = 100.0
       end select
   #+END_SRC

* Beispiele                                                      :B_appendix:
  :PROPERTIES:
  :BEAMER_env: appendix
  :END:

** Programm: Example 1

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example1.f08
       <<example1>>
   #+END_SRC

** Programm: Example 2

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example2.f08
     program example2
       implicit none
       integer :: i
       <<example2>>
       print *, "*** Example 2 ***"
       print *, "iarray = ", iarray
       print *, "iarray2 = ", iarray2
       print *, "iarray3 = ", iarray3
     end program example2
   #+END_SRC

** Programm: Example 3

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example3.f08
     program example3
       complex :: a
       complex :: b
       print *, "*** Example 3 ***"
       a = (2, 1)
       b = (-1, 2)
       print *, "a = ", a
       print *, "b = ", b
       <<example3>>
     end program example3
   #+END_SRC

** Programm: Example 4-6

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example46.f08
     program example46
       implicit none
       integer :: a = 5, b = -1
       integer :: i
       print *, "*** Beispiel 4-6 ***"
       print *, "a = ", a
       print *, "b = ", b
       <<example4>>
       <<example5>>
       <<example6>>
     end program example46
   #+END_SRC

** Programm: Example 7

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example7.f08
     program example7
       implicit none
       real, dimension(3) :: a, b
       real :: vol, circ
       print *, "*** Beispiel 7 ***"
       a = [1., 2., 3.]; b = [-1., 2., 1.]
       call volume_and_length (a, b, vol, circ)
       print *, "a = ", a, "b = ", b
       print *, "vol = ", vol, "circ = ", circ
     end program example7
     <<example7>>
   #+END_SRC

** Programm: Example 8

   #+BEGIN_SRC f90 :export code :noweb yes :tangle examples/example8.f08
     program example8
       implicit none
       <<example8>>
     end program example8
   #+END_SRC

* Lösung
** Aufgabe: Funktionen
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   #+BEGIN_SRC f90 :export code :noweb yes :tangle solutions/solutions1.f08
     program solution1
       implicit none
       integer :: i
       integer, dimension(10) :: i_vector
       real, dimension(5) :: r_vector
       print *, "*** Lösung 1 ***"
       i_vector = [(i, i = 1, 10)]
       r_vector = [(0.2 * i, i = 1, 5)]
       print *, "sum_vector: ", sum_vector (i_vector)
       print *, "product_vector: ", product_vector (r_vector)
       print *, "non_zero_element: ", non_zero_element (i_vector - 1)
     contains
       <<solution1>>
       <<solution2>>
       <<solution3>>
     end program solution1
   #+END_SRC
   #+NAME: solution1
   #+BEGIN_SRC f90 :export none
     integer function sum_vector (vector) result (sum)
        integer, dimension(:), intent(in) :: vector
        integer :: i, n_vector
        n_vector = size (vector)
        sum = 0
        do i = 1, n_vector
           sum = sum + vector(i)
        end do
      end function sum_vector
   #+END_SRC
   #+NAME: solution2
   #+BEGIN_SRC f90 :export none
     real function product_vector (vector) result (product)
        real, dimension(:), intent(in) :: vector
        integer :: i, n_vector
        n_vector = size (vector)
        product = 1
        do i = 1, n_vector
           product = product * vector(i)
        end do
      end function product_vector
   #+END_SRC
   #+NAME: solution3
   #+BEGIN_SRC f90 :export none
     logical function non_zero_element (vector) result (yorn)
         integer, dimension(:), intent(in) :: vector
         yorn = .not. any (vector == 0) ! all (vector /= 0)
       end function non_zero_element
   #+END_SRC
