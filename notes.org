#+startup: beamer
#+OPTIONS: H:1
#+LATEX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [smaller]
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+BEAMER_THEME: default
#+BEAMER_COLOR_THEME: solarized [accent=green]
#+BEAMER_FONT_THEME:
#+BEAMER_INNER_THEME:
#+BEAMER_OUTER_THEME:
#+BEAMER_HEADER:

#+LATEX_HEADER: \usemintedstyle{autumn}

* Fortran Workshop

** Übersicht

   - Einführung 20 Minuten
   - Vorbereitung (Installation Kompiler) 5 Minuten
   - Geschichte 15 Minuten
   - Syntax I (intrinsische Datentypen, I/O und Module) 10 Minuten
   - Übung 10 Minuten
   - Besprechung Übung 10 Minuten
   - Syntax II (=allocatable= und /array language/) 20 Minuten
   - Übung 20 Minuten
   - Besprechung Übung 20 Minuten
   - 15 Minuten Pause
   - Syntax III (=derived types= und =pointer=) 30 Minuten
   - Übung 30 Minuten
   - Besprechung Übung 30 Minuten


* Begrüßung

** Tutoren

   - Simon Braß, Doktorand in der AG Theoretische Teilchenphysik
   - Jessica Reuter, Lehramt für Mathematik und Informatik

** Ablauf                                                    :B_exampleblock:
   :PROPERTIES:
   :BEAMER_env: exampleblock
   :END:

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 1. Tag: Grundlagen

     - Vorbereitung
     - Geschichte
     - Konzepte und Syntax
     - Strukturen
     - Datentypen
     - Ein-/Ausgabe

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :END:

**** 2. Tag: OOP

     - Zeiger und Prozeduren-Zeiger
     - =allocatables=
     - Polymorphie und Vererbung
     - Typ-gebundene Prozeduren

* Vorbereitung

** Editor

   - Emacs
   - Vim / vi / kak
   - Sublime
   - Atom

** Kompiler

   - nagfor
   - ifort
   - *gfortran*

** Anleitungen und Material

   Anleitungen und Material unter: [[http://www.tp.nt.uni-siegen.de/+brass/]]

* Geschichte

  - Entwicklung durch ???
  - Standardisierung / Nomenklatur
  - "Modernes" Fortran / Unterschied zu Fortran 77
  - Kompiler (Intel, GCC, Nagfor, Portland, ???)

* Eigenschaften von Fortran

** Formula Translator (Fortran)

   - 1950er :: Entwicklung bei IBM um das Team von John Backus als Assembler-Alternative
   - 1966 :: 1. Standardisierung durch ANSI als =FORTAN 66=
   - 1978 :: 2. Standardiserung als =FORTRAN 77= / Durchbruch als Sprache
   - 1991 :: Einführung von abstrakten Datentypen und /data hiding/, sowie Standardisierung der /array language/
   - 1997 :: Fortran 95 als /high perfomance/ Sprache
   - 2004 :: Fortran 2003 mit Objekt-orientierten Konzepten
   - 2008 :: Fortran 2008 mit /submodules/ und /coarrays/
   - 2012-heute :: Fortran 2015 ...

* Philosophie von Fortran

  - einfach-lesbare Syntax
  - Entwicklung für Lochkarten-Computer *fixed form* für =FORTAN 66/77=
  - Seit =Fortran 90= *free form* als Standard
  - vergleichbare Effizienz zu Assembler-Code

* Beispiele

** /fixed form/

   #+BEGIN_SRC fortran
     c     independent variables for real graph: number of final state
     c     legs times 3, take away 4 for 4-momentum conservation, add 2
     c     for x_1 and x_2, and take away an overall azimuth
           real * 8 btilde,xx(ndiminteg),www0
           real * 8 xrad(3)
           real * 8 xborn(ndiminteg-3)
   #+END_SRC

** /free form/

   #+BEGIN_SRC f90
       call self%rand_gen%rand(randkoord)
       randkoord = self%sys_len * randkoord
       m = int(randkoord(1)) + 1
       n = int(randkoord(2)) + 1
       call cyclic_coord (self, m, n, up, down, left, right)

       deltaE = 2.0_dp * ( self%couple_const * self&
            &%grid(m, n)*(self%grid(m, left) + self%grid(m, right) +&
            & self%grid(up, n) + self%grid(down, n)) + self%mag_field &
            &* self%grid(m, n))
   #+END_SRC

* Fortran 2003 Standard

  - größte Kompiler-Unterstützung (Intel/NAGfor/GFortran): =Fortran 2003=
  - Neuerungen in =Fortran 2003=

** Neuerungen in =Fortran 2003=

   - =derived types= :: =parametrized derived types=, Konstruktoren und Destruktoren (Finalizer) und Beschränkung der Zugriffbarkeit
   - OOP :: Type-Erweiterung und Vererbung, Polymorphie, dynamische Type-Allokierung und Type-gebundene Prozeduren
   - Datenmanipulierung :: allokiebare Komponenten, =deferred type parameters=, ...
   - =procedure pointer= ::
   - =C bindings= ::
   usw.

   (Fast) vollständige Unterstützung des =Fortran 2003= Standards nur durch GCC [[https://gcc.gnu.org/wiki/Fortran2003Status][siehe]]

* Parallelisierung

** Threading

   - Parallelisierung mit OpenMP durch Direktiven mit Threads standardisiert

** Message-Passing Interface

   - Parallelisierung im Message-Passing Interface standardisiert

* Konzepte und Syntax

** Vorteile von =Fortran=

   - gewöhnliche Sprache
   - Syntax nahe an Matrix- und Vektorproblemen
   - strenge Speicherverwaltung
   - Polymorphie mit Typ-Sicherheit

** Nachteile von =Fortran=

   - schlechte Kompiler-Unterstützung
   - keine Templates (=C++=)

* Hauptprogramm und Module

** Scope

   Definition eines Scopes durch Strukturen
   - Hauptprogramm
   - Module
   - Prozeduren
   - =derived types=

** /data hiding/

   - Verschachtelung von Scopes
   - Zugriff auf Daten eines niedrigeren Scopes
   - kein Zugriff auf Daten eines höhren Scopes
   - explizites Öffnen / Verschließen von Daten

* Beispiel Syntax und Konzepte

*** Hauptprogramm                                            :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Hauptprogramm                                           :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       program beispiel
         ! use beispiel_module
         implicit none
         ! Variablen-Deklaration
         ! Programm
       contains
         ! Prozeduren
         ! Zugriff auf alle Variablen
         ! des Hauptprogrammes
       end program beispiel
     #+END_SRC

*** Modul                                                    :B_column:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: column
    :END:

**** Modul                                                   :B_exampleblock:
     :PROPERTIES:
     :BEAMER_env: exampleblock
     :END:
     #+BEGIN_SRC f90
       module beispiel_module
         use beispiel2_module
         ! Variablen-Deklarationen
         ! Typ-Definitioen
         !
       contains
         ! Module-Prozeduren
         ! Zugriff auf alle Variablen
         ! des Moduls
       end module beispiel_module
     #+END_SRC

* Datentypen

** Intrinsiche Datentypen

   #+BEGIN_SRC f90
       integer :: i                  ! Ganze Zahlen
       real :: x                     ! Reelle Zahlen
       complex :: z                  ! Komplexe Zahlen
       character(len=100) :: str     ! Zeichenkette mit Länge 100
       logical :: flag               ! Boolean (.True. oder .False.)
       type(haus) :: eigenheim       ! Derived Type
   #+END_SRC

** =implicit none=                                             :B_alertblock:
   :PROPERTIES:
   :BEAMER_env: alertblock
   :END:

   *Wichtig:* Aus Rückwartskompatibilität immer =implicit none= benutzen, damit Fortran nicht automatisch Variablen mit entsprechenden Typen deklariert.

* Ein- und Ausgabe

** Listen-formatierte Ein-/Ausgabe
   #+BEGIN_SRC f90
     print *, "Hallo Welt!"
     write (*, *) "Hallo Welt!"
     write (*, *) "Geben Sie einen ganze Zahl ein:"
     read (*, *) i
   #+END_SRC

* =derived types=
  Einfacher =derived type=
  #+BEGIN_SRC f90
    ! Typ Definition
    type :: haus_t
       real :: length
       real :: width
       real :: height
    end type haus_t
    type(haus_t) :: eigenheim
    ! Konstruktor
    eigenheim = haus_t (10.0, 8.0, 12.0) ! Länge, Breite und Höhe
    eigenheim = haus_t ( &               ! Beliebige Reihenfolge
         width = 8.0, &                  ! mit explizitem Aufruf
         height = 12.0, &                ! der Argumente
         length = 10.0)
    ! Oder eigener Konstruktor durch ein überladenes Interface von haus_t
  #+END_SRC
  Erweiterer =derived type= mit Vererbung
  #+BEGIN_SRC f90
      type, extends(haus_t) :: halle_t
         character(len=20) :: fassadenfarbe = "grün"
         logical :: brandschutz = .false.
      end type halle_t
      type(halle_t) :: gewerbe ! hat alle Eigenschaften von haus_t und hallo_t
  #+END_SRC

** Weitere Attribute

   - public ::
   - private ::
   - allocatable :: Speicher kann dynamisch mit =allocate= bereit gestellt werden
   - pointer :: Zeigevariable (kann Variable mit Attribut =target= zeigen)
   - target :: Zielvariable
   - dimension :: Variable ist ein Array (max. 7 dimensional)
   - intent :: im Kontext einer Prozeduren: =in=, =out= oder =inout=, legt fest wie Variable in der Prozedure benutzt werden kann
   - optional ::
   - save ::

   #+BEGIN_SRC f90
       integer, public :: test ! Ist in allen Programmteilen sichtbar
       integer, private :: private_test ! Ist in anderen Modulen nicht sichtbar/außerhalb eines Types
       integer, dimension(10) :: array ! 1-dim. Array mit zehn Elementen
       integer, dimension(:), allocatable :: alloc_array ! allokierbare, 1-dim. Array
       integer, pointer :: zeiger
       integer, target :: ziel = 42
       !
       allocate (alloc_array(25)) ! allokiere 25 Elemente
       zeiger => ziel
       zeiger => test ! Gibt eine Fehlermeldung
   #+END_SRC

* Polymorphe Objekte und Type-gebundene Prozeduren

  #+BEGIN_SRC f90
      class(haus_t), allocatable :: objekt ! Polymorphes Objekt auf Basis von haus_t
      allocate (halle_t :: objekt) ! allokiere vererbten Typ halle_t von haus_t
      select type (object) ! Typ-sicherer Aufruf
      type is (halle_t)
         object%brandschutz = .true.
      class is (haus_t)
         object%length = 100.0
      end select
  #+END_SRC
